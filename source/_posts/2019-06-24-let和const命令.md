---
title: let和const命令
tags: [ES6]
toc: true
mathjax: true
date: 2019-06-24 20:01:17
categories:
    - 编程语言
    - JavaScript
    - ES6
---

## let

1. 只在块级作用域内有效。
2. 不存在变量提升。
3. 暂时性死区，只要块级作用域内存在`let`命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前使用这些变量，就会报错（无论父级作用域是否定义了这些变量），这意味着`typeof`不再是一个百分百的安全操作。
4. 不允许重复声明同一个变量。
5. `for`循环有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。

## 块级作用域

1. ES5 规定函数只能在顶层作用域和函数作用域进行声明，不能再块级作用域中进行声明，但是浏览器为了兼容以前的旧代码，并没有遵守这个规范。 ES6 明确规定允许在块级作用域中声明函数。
2. ES5 中，函数的整条声明语句会被提升到函数头部或顶级作用域头部
3. ES6 的浏览器函数声明的限制（其他环境的实现不用遵守，还是将块级作用域中的函数声明当作`let`处理）：
    - 允许在块级作用域内声明函数
    - 函数声明类似于`var`，会提升到全局作用域或函数作用域的头部
    - 同时，函数声明还会提升到块级作用域的头部
4. 考虑到环境的行为差异太大，不建议在块级作用域内进行函数声明，如果要使用，最好使用函数表达式。
5. ES6 的块级作用域必须有大括号，如果没有大括号，`JS`引擎就认为不存在块级作用域。

## const

1. `const`声明一个常量，一旦声明，常量的值不允许改变。单对于复合类型数据（例如对象，数组），其只能保证指向内存地址的指针不改变，无法保证其数据结构不变。可以使用`Object.freeze`进行冻结（只能冻结改对象的属性，如果其属性是一个对象，只能保证指针不变，无法保证子对象的属性不变）。
2. 必须立即初始化。
3. 只在块级作用域内有效。
4. 不存在变量提升。
5. 暂时性死区。
6. 不允许重复声明。

## ES6 声明变量的六种方法

1. var
2. function
3. let
4. const
5. import
6. class

### 顶层对象属性

1. `var`和`function`命令声明的全局变量，依旧是顶层对象的属性。
2. `let`、`const`、`class`命令声明的全局变量，不属于顶层对象的属性。

### globalThis 对象

1. 不同环境中指向顶层对象的变量不同
    - 浏览器：self 和 this
    - Web Worker：self
    - Node: global
2. 全局环境中，`this`返回的是顶层对象。但是，在`ES6`模块和`Node`模块中，`this`返回的是当前模块。
3. 函数里面的 this，如果函数不是作为对象的方法允许，而是单纯作为函数允许，`this`会指向顶层对象。但是，在严格模式下，`this`会返回`undefined`。
4. 不管是在严格模式还是普通模式，`new Function('return this')()`总是返回全局对象。但是，如果浏览器使用了 CSP（Content Security Policy，内容安全策略），那么`eval`，`new Function`这些方法可能无法使用。
